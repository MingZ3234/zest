fail.run=Failed to execute unit test
no.annotation.zest=No @ZestTest annotation found
file.found=File (%1$s) not found
no.data=No test case data found

parse=Failed to parse test case data (%1$s)
parse.common.attr=Failed to get attribute %2$s on <%1$s>
parse.common.attr.unknown=<%1$s> does not support attribute %2$s
parse.common.attr.duplicate=Duplicate attribute %1$s="%2$s"
parse.common.attr.empty=The value of attribute %1$s cannot be empty
parse.common.class.found=Unable to get class %1$s
parse.common.children=<%1$s> should not have child elements
parse.common.children.unknown=<%1$s> does not support child elements <%2$s>
parse.common.children.list=<%1$s> must be a list of <%2$s>

parse.zest=The root element <Zest> could not be found
parse.zest.necessary=<Zest> must and can only have three sub-elements: <Description>, <Sources> and <Param> (and the order is fixed)
parse.sources.error=<Sources> parsing failed
parse.source.error=<Source Id="%1$s"> parse failed
parse.source.necessary=<Source> must and can only have two elements <Init> and <Verify> (and the order is fixed)
parse.source.init.error=<Init> parse failed
parse.source.verify.error=<Verify> parsing failed
parse.source.operation.match=According to the bound operator (%1$s), <%2$s> must be a list of <%3$s>
parse.source.operation.unknown=Unsupported operator (%1$s)
parse.source.operation.none=No binding operator

parse.table.error=<Table Name="%1$s"> parse failed
parse.table.meta=Failed to parse database MetaData
parse.table.sort.exist=<Sort Field="%1$s"> Can\u2019t find the corresponding field in the actual database
parse.table.rule=<Rule Path="%1$s"> Can\u2019t find the corresponding field in the actual database

parse.collection.error=<Collection Name="%1$s"> parse failed
parse.collection.sort.exits=<Sort Field="%1$s"> Cannot find the corresponding field in the actual database (in other words, it needs to match the field of the EntityClass corresponding class of <Collection>)
parse.collection.rule=<Rule Path="%1$s"> Cannot find the corresponding field in the actual database (in other words, it needs to match the field of the EntityClass corresponding class of <Collection>)

parse.sorts.error=<Sorts> parsing failed
parse.sorts.position=Only the <Table> or <Collection> under <Verify> can add elements <Sorts>
parse.sorts.order=<Sorts> must be before <Rules> and <Data>, and there can only be one
parse.sort.error=<Sort Field="%1$s"> parse failed
parse.sort.direction=The content of the Direction attribute must be asc or desc (if it is empty, the default is asc)

parse.rules.error=<Rules> parsing failed
parse.rules.position=<Rules> must be before <Data> and there can only be one
parse.rule.error=Failed to parse <Rule> of attribute Path="%1$s"
parse.rule.choice=It must be one of <RegExp>, <CurrentTime> or <FromCurrentTime> under <Rule>
parse.rule.from.unit.unknown=<FromCurrentTime> Property Unit value (%1$s) is not supported

parse.param.error=<Param> parsing failed
parse.param.none=<ParamField Name="%1$s"> Cannot find the corresponding attribute field in the test parameter object
parse.param.obj.load=<ParamField Name="%1$s"> failed when testing parameter object based on content assignment
parse.param.nonsupport.map=Does not support automatic assignment of Map type attributes

parse.data.error=Failed to parse <Data> on line %1$d
parse.data.table.row.exist=The field %1$s described by <Data> cannot be found in the actual database table %2$s

verify.start=<Source Id="%1$s"><Verify><Table Name="%2$s"> Start verifying data...
verify.row.rule.nonuse=Although <Rule Path="%1$s"> specifies the validation rules, the <Data> data in row %2$d clearly specifies the expected value, and the content in <Data> is used for validation
verify.row.error=<Source Id="%1$s"><Verify><Table Name="%2$s"> Line %3$d <Data> verification failed
verify.row.data.null=%1$s must be a NULL value
verify.row.data.date=%1$s type must be java.util.Date
verify.row.data=The value of %1$s must be %2$s
verify.doc.size=<Source Id="%1$s"><Verify><Collection> The number of <Data> does not match the actual

parse.date=Date format like "%1$s" is not supported

parse.operation=@ZestSource can only be annotated on attributes of type javax.sql.DataSource or org.springframework.data.mongodb.core.MongoOperations

duplicate.operation=@ZestSource's value="%1$s" is set repeatedly

init.executor=Failed to create instance of executor %1$s
init.param=There can only be one parameter in the method and it must be a subclass of com.github.bookong.zest.core.testcase.ZestParam

executor.match=Executor does not match the data type

statement.evaluate=Execution of unit test "%1$s" failed
statement.run=[Zest] Test case "%1$s"

ignore.target.data=Data source (%1$s) ignores data validation
ignore.target.table=Data source (%1$s) table (%2$s) ignores data validation

check.ds=Failed to verify data source (%1$s)
check.table.size=Verify the number of data in the data source (%1$s) table (%2$s)
check.table.col.date=The %3$d row (%4$s) of the data source (%1$s) table (%2$s) must be Date or Long
check.table.col.date.current=The %3$d row (%4$s) of the data source (%1$s) table (%2$s) must be the current time
check.table.col.date.from=The %3$d row and column (%4$s) of the data source (%1$s) table (%2$s) must be the specified distance from the current time
check.table.col.regexp=The %3$d row and column (%4$s) of the data source (%1$s) table (%2$s) must match the regular expression: %5$s
