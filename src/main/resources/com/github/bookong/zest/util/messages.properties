run=[Zest] Test case "%1$s"
run.fail=Failed to execute unit test
no.data=No test case data found
no.annotation.zest=No @ZestTest annotation found
file.found=File (%1$s) not found

parse=Failed to parse test case data (%1$s)
parse.common.attr=Failed to get attribute %2$s on <%1$s>
parse.common.attr.unknown=<%1$s> does not support attribute %2$s
parse.common.attr.duplicate=Duplicate attribute %1$s="%2$s"
parse.common.attr.empty=The value of attribute %1$s cannot be empty
parse.common.class.found=Unable to get class %1$s
parse.common.children=<%1$s> should not have child elements
parse.common.children.unknown=<%1$s> does not support child elements <%2$s>
parse.common.children.list=<%1$s> children elements must be a list of <%2$s>

parse.zest=The root element <Zest> could not be found
parse.zest.necessary=<Zest> must and can only have three sub-elements: <Description>, <Sources> and <Param> (and the order is fixed)
parse.sources.error=<Sources> parsing failed
parse.source.error=<Source Id="%1$s"> parse failed
parse.source.necessary=<Source> must and can only have two elements <Init> and <Verify> (and the order is fixed)
parse.source.init.error=<Init> parse failed
parse.source.verify.error=<Verify> parsing failed
parse.source.operation.match=According to the bound operator %1$s, the children elements of <%2$s> must be a list of <%3$s>
parse.source.operation.unknown=Unsupported operator %1$s

parse.table.error=<Table Name="%1$s"> parse failed
parse.table.meta=Failed to parse database MetaData
parse.table.sort.exist=<Sort Field="%1$s"> Can\u2019t find the corresponding field in the actual database
parse.table.rule=<Rule Path="%1$s"> Can\u2019t find the corresponding field in the actual database

parse.collection.error=<Collection Name="%1$s"> parse failed
parse.collection.sort.exits=<Sort Field="%1$s"> Cannot find the corresponding field in the actual database (in other words, it needs to match the field of the EntityClass corresponding class of <Collection>)
parse.collection.rule=<Rule Path="%1$s"> Cannot find the corresponding field in the actual database (in other words, it needs to match the field of the EntityClass corresponding class of <Collection>)

parse.sorts.error=<Sorts> parsing failed
parse.sorts.position=Only the <Table> or <Collection> under <Verify> can add elements <Sorts>
parse.sorts.order=<Sorts> must be before <Rules> and <Data>, and there can only be one
parse.sort.error=<Sort Field="%1$s"> parse failed
parse.sort.direction=The content of the Direction attribute must be asc or desc (if it is empty, the default is asc)

parse.rules.error=<Rules> parsing failed
parse.rules.position=<Rules> must be before <Data> and there can only be one
parse.rule.error=<Rule Path="%1$s"> parse failed
parse.rule.choice=It must be one of <RegExp>, <CurrentTime> or <FromCurrentTime> under <Rule>
parse.rule.from.unit.unknown=<FromCurrentTime> Property Unit value (%1$s) is not supported

parse.operator=@ZestSource(value="%1$s") can only be annotated on attributes of type javax.sql.DataSource or org.springframework.data.mongodb.core.MongoOperations
parse.operator.duplicate=@ZestSource(value="%1$s") Repeat setting

parse.executor=@ZestSource(value="%1$s" executorClass=%2$s.class) failed to create an instance of the executor

parse.param.error=<Param> parsing failed
parse.param.none=<ParamField Name="%1$s"> Cannot find the corresponding attribute field in the test parameter object
parse.param.obj.load=<ParamField Name="%1$s"> failed when testing parameter object based on content assignment
parse.param.nonsupport.map=Does not support automatic assignment of Map type attributes
parse.param.init=The method %1$s() annotated by @ZestTest must have one and only one parameter, and must be a subclass of com.github.bookong.zest.core.testcase.ZestParam

parse.data.error=Failed to parse <Data> on line %1$d
parse.data.table.row.exist=The field %1$s described by <Data> cannot be found in the actual database table %2$s
parse.data.date=Failed to parse date "%1$s"
parse.data.date.pattern=Only four time pattern are supported: "yyyy-MM-dd HH:mm:ss"; "yyyy-MM-dd HH:mm"; "yyyy-MM-dd HH"; "yyyy-MM-dd"

operator.unbound=@ZestSource(value="%1$s") annotation not found
operator.cast=@ZestSource(value="%1$s") annotated operator cannot be converted from %2$s to %3$s

verify.ignore=<Source Id="%1$s"> Ignore data verification
verify.table.ignore=<Source Id="%1$s"><Verify><Table Name="%2$s"> Ignore data verification
verify.table.start=<Source Id="%1$s"><Verify><Table Name="%2$s"> Start verifying data...
verify.table.executor=The executor %1$s does not match the <Table> type element
verify.table.size=<Source Id="%1$s"><Verify><Table Name="%2$s"> The quantity of <Data> does not match the actual

verify.row.error=<Source Id="%1$s"><Verify><Table Name="%2$s"> No. %3$d <Data> data verification failed
verify.row.rule.nonuse=Although <Rule Path="%1$s"> specifies the validation rules, the <Data> data in row %2$d clearly specifies the expected value, and the content in <Data> is used for validation
verify.row.data.null=%1$s must be a NULL value
verify.row.data.date=%1$s type must be java.util.Date
verify.row.data=The value of %1$s must be %2$s

verify.collection.ignore=<Source Id="%1$s"><Verify><Collection Name="%2$s"> Ignore data verification
verify.collection.start=<Source Id="%1$s"><Verify><Collection Name="%2$s"> Start verifying data...
verify.collection.executor=The executor %1$s does not match the <Collection> type element
verify.collection.size=<Source Id="%1$s"><Verify><Collection Name="%2$s"> The quantity of <Data> does not match the actual

verify.document.error=<Source Id="%1$s"><Verify><Collection Name="%2$s"> No. %3$d <Data> data verification failed

check.table.col.date=The %3$d row (%4$s) of the data source (%1$s) table (%2$s) must be Date or Long
check.table.col.date.current=The %3$d row (%4$s) of the data source (%1$s) table (%2$s) must be the current time
check.table.col.date.from=The %3$d row and column (%4$s) of the data source (%1$s) table (%2$s) must be the specified distance from the current time
check.table.col.regexp=The %3$d row and column (%4$s) of the data source (%1$s) table (%2$s) must match the regular expression: %5$s
